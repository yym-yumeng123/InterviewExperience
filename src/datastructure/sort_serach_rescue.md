## 递归

#### 理解递归

- 去的过程叫`递`，
- 回来的过程叫`归`

递归需要满足三个条件:

1. 一个问题的解可以分解为几个子问题的解
   - 子问题就是数据规模更小的问题
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
3. 存在递归终止条件

#### 如何编写递归代码

写递归代码最关键的是`写出递推公式，找到终止条件`

看一个例子: 假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？

1. 根据第一步的走法把所有走法分为两类, 第一类是第一步走了 1 个台阶, 另一类是第一步走了 2 个台阶
2. 所以 n 个台阶的走法就等于先走 1 阶后, `n-1个台阶的走法` + 先走两阶后, `n-2个台阶的走法`
3. 终止条件就是 `f(1) = 1, f(2) = 2`

```md
f(1) = 1;
f(2) = 2;
f(n) = f(n-1)+f(n-2)
```

```js
// 递归方式
function f(n) {
  if (n === 1) return 1
  if (n === 2) return 2
  return f(n - 1) + f(n - 2)
}

// 非递归
function f(n) {
  if (n === 1) return 1
  if (n === 2) return 2

  let ret = 0
  let pre = 2
  let prepre = 1
  for (let i = 3; i <= n; ++i) {
    ret = pre + prepre
    prepre = pre
    pre = ret
  }
  return ret
}
```

:::tip
编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤
:::

#### 递归代码警惕堆栈溢出/重复计算

> 函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。

- 限制递归调用的最大深度
  - 递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错


## 排序

#### 如何分析一个排序算法

1. 执行效率
   - 最好情况、最坏情况、平均情况时间复杂度
   - 时间复杂度的系数、常数 、低阶
   - 比较次数和交换（或移动）次数
2. 内存消耗
   - 内存消耗可以通过空间复杂度来衡量，排序算法也不例外, 针对排序算法的空间复杂度，我们还引入了一个新的概念 `原地排序`
   - 原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法
3. 稳定性
   - `2,9,3,4,8,3`
   - 某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法；
   - 如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。


#### 冒泡排序