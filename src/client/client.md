## 跨域

- 因为浏览器出于安全考虑，有`同源策略`
  - 如果`协议、域名或者端口`有一个不同就是跨域
- 主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求

**jsonp**

JSONP 的原理很简单，就是利用 `<script> 标签没有跨域限制的漏洞。通过 <script> 标签指向一个需要访问的地址并提供一个回调函数来接收数据`

```js
<script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
<script>
    function jsonp(data) {
    	console.log(data)
	}
</script>
```

**CORS**

- CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现
- 服务端设置 `Access-Control-Allow-Origin` 就可以开启 CORS

**document.domain**

- 该方式只能用于`二级域名相同的情况下`，比如 a.test.com 和 b.test.com 适用于该方式。
- 只需要给页面添加 `document.domain = 'test.com'` 表示二级域名都相同就可以实现跨域

**postMessage**

- 方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息

```js
// 发送消息端
window.parent.postMessage("message", "http://test.com")
// 接收消息端
var mc = new MessageChannel()
mc.addEventListener("message", (event) => {
  var origin = event.origin || event.originalEvent.origin
  if (origin === "http://test.com") {
    console.log("验证通过")
  }
})
```

## 浏览器缓存机制

1. 缓存位置: 从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络
   - `Service Worker`
   - `Memory Cache` 也就是内存中的缓存
     - 对于大文件来说, 大概率不存储在内存中的, 反之优先
   - `Disk Cache` 存储在硬盘中的缓存
     - 比之 `Memory Cache` 胜在容量和存储时效上
     - 并且既使在跨站点的情况下, 相同地址的资源一旦被硬盘缓存下来, 就不会再次去请求数据
   - `Push Cache`
     - 是 `HTTP/2` 中的内容, 以上三种缓存都没命中, 才会使用, 缓存时间很短暂, 只在会话中存在
   - 网络请求
2. 缓存策略: 浏览器缓存策略分为: `强缓存和协商缓存`, 并且缓存策略都是通过设置 `HTTP Header`来实现的

强缓存

通过设置两种: HTTP Header 实现 `Expires 和 Cache-Control`. 强缓存表示在缓存期间不需要请求, `status code 200`

- `Expires` 过期时间: `Expires 是 HTTP/1` 的产物, 表示资源会在什么时候后过期, 需要再次请求. 并且 Expires 受限于白底事件, 如果修改了本地时间, 可能会造成缓存时效
- `Cache-Control: max-age=30` 也是出现于 `HTTP/1.1`, 优先级高于 Expires, 该属性值表示资源会在 30s 后过期, 需要再次请求

协商缓存: 如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 `HTTP Header 实现：Last-Modified 和 ETag`

- `Last-Modified 和 If-Modified-Since:` Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。
- `ETag 和 If-None-Match: ` ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高

## 浏览器渲染机制

- 执行 JS 有一个 JS 引擎, 那么执行渲染也有一个`渲染引擎`
- DOM: `Document Object Model` 浏览器将 HTML 解析成树形的数据结构，简称 DOM
- CSSOM: `CSS Object Model` 浏览器将 CSS 代码解析成树形的数据结构
- DOM 和 CSSOM 都是以 `Bytes → characters → tokens → nodes → object model`.这样的方式生成最终的数据
- Render Tree: DOM 和 CSSOM 合并后生成 Render Tree

![渲染](render.webp)
![渲染](renderpic.webp)

1. 用户输入一个 `URL`, 浏览器会发送一个请求, 请求 `URL` 的资源
2. 浏览器的 `HTML解析器` 会将这个文件解析, 构建一颗 `DOM` 树, (生成 DOM 的最开始阶段(Bytes -> characters)后, 并行发起 `css 图片 js` 的请求)
   1. 注意: 发起 js 文件的下载 request 并不需要 DOM 处理到那个 script 节点
3. 在构建 DOM 树的时候,遇到 js 和 css 元素, HTML 解析器就将控制权转让给`JS解析器`或者`CSS解析器`, 开始构建 `CSSOM`
4. DOM 树构建完之后, 浏览器会把 DOM 树中的一些不可见元素去掉, 与 CSSOM 合成一颗 `render tree`
5. `Layout`: 有了 `Render Tree`, 浏览器知道网页中有哪些节点, 各个节点的 CSS 定义以及从属关系, 下一步操作就是 `Layout`, 计算出每个节点在屏幕中的位置
6. `Painting`: 浏览器已经知道了那些节点要显示, 每个节点的 CSS 属性是什么, 每个节点在屏幕里的位置, 按照算出来的规则, 把内容画到屏幕上

:::tip

上面几个步骤因为 `DOM CSSOM Render Tree` 都可能在第一次 `Painting` 后被更新多次, 比如 JS 修改了 DOM 或者 CSS 属性. layout 和 Painting 也会重复执行, 除了`DOM、CSSOM`更新的原因外，图片下载完成后也需要调用`Layout 和 Painting`来更新网页
:::

为什么操作 DOM 慢?

- 因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信

## Repaint Reflow

`重绘（repaints）`是一个元素外观的改变所触发的浏览器行为，例如改变 vidibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随回流。

`回流（reflow）`布局或者几何属性需要改变就称为回流

引起重绘和回流的一些操作

- 当你增加、删除、修改 DOM 结点时，会导致 Reflow 或 Repaint
- 当你移动 DOM 的位置，或是搞个动画的时候
- 当你修改 CSS 样式的时候
- 当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候。
- 当你修改网页的默认字体时
  - 注：`display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint`，因为没有发现位置变化。

减少重绘和回流

- 使用 `transform 替代 top`
- 使用 `visibility 替换 display: none` ，因为前者只会引起重绘，后者会引发回流
- 不要把节点的属性值放在一个循环里当成循环里的变量
- 不要使用 `table 布局`，可能很小的一个小改动会造成整个 table 的重新布局
- 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame
- CSS 选择符从右往左匹配查找，避免节点层级过多

## 安全防范

1. `XSS: ` 攻击者想尽一切办法将可以执行的代码注入到网页中, 分为两类：`持久型和非持久型。`

   - 持久型也就是攻击的代码被服务端写入进数据库中
   - 对于评论功能来说，就得防范持久型 XSS 攻击
   - 非持久性: 一般通过修改 URL 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击

   - 防御 1: `转义字符`
   - 防御 2: `CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行`
     - `Content-Security-Policy: default-src ‘self’;` `Content-Security-Policy: img-src https://*`

2. `CSRF: ` 跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑

   - Get 请求不对数据进行修改
   - 不让第三方网站访问到用户 Cookie
   - 阻止第三方网站请求接口
   - 请求时附带验证信息，比如验证码或者 Token

3. `点击劫持: ` 是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击

4. `中间人攻击: ` 是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息
   - 不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况
   - 只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻

## 输入 URL 页面渲染的整个流程

1. 输入 URL, 会进行 URL 解析, DNS 查询, DNS 的作用就是通过域名查询到具体的 IP
   - 操作系统会首先在本地缓存中查询 IP
   - 没有的话会去系统配置的 DNS 服务器中查询
   - 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器
   - 然后去该服务器查询 google 这个二级域名
   - 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP
2. TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了。

3. 浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错

4. 浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。

5. 文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。

6. CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西

7. Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了

## UDP

> 不需要在正式传递数据之前先连接起双方。然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且 UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便

1. UDP 协议是面向无连接的
   - 不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了
   - 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
   - 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作
2. 不可靠性
   - 不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠
3. 高效

   - 正是因为它不是那么的可靠，所以也就没有 TCP 那么复杂了，需要保证数据不丢失且有序到达
   - UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。

4. 传输方式
   - UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

## TCP

> TCP 基本是和 UDP 反着来，建立连接断开连接都需要先需要进行握手。在传输数据的过程中，通过各种算法保证数据的可靠性，当然带来的问题就是相比 UDP 来说不那么的高效

不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 是一个全双工的协议

1. 建立连接三次握手

- 第一次握手: 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。
- 第二次握手: 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。
- 第三次握手: 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功

2. 为什么 TCP 建立连接需要三次握手，明明两次就可以建立起连接

- 为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。

3. 断开链接四次握手

- 第一次握手: 客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求
- 第二次握手: B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。
- 第三次握手: B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。
- 第四次握手: A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态, 若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态

## HTTP & TSL

- `副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。`
- 幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上`资源的状态一致`

---

1. http 请求由三部分组成: `请求行 首部 实体`
   - 请求行 `GET /images/log.gif HTTP/1.1`
2. `Post Get 区别`
   - Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册
   - Post 相对 Get 安全一点点，因为 Get 请求都包含在 URL 里（当然你想写到 body 里也是可以的），且会被浏览器保存历史纪录。Post 不会，但是在抓包的情况下都是一样的
   - URL 有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的
   - Post 支持更多的编码类型且不对数据类型限制
3. `HTTP首部` 首部分为请求首部和响应首部，并且部分首部两种通用

- 通用首部
  - `Cache-control` 控制缓存
  - `Connection` 浏览器想要使用的连接类型: `keep-alive`
  - `Date` 创建报文时间
  - `Transfer-Encoding` 传输编码方式
- 请求首部
  - `Accept: `能正确接受的每次类型
  - `Accept-charset: ` 能正确接受的字符集
  - `Accept-Encoding: ` 能正确接收的编码格式列表
  - `Accept-Language: ` 能正确接受的语言列表
  - `User-Agent: ` 客户端信息
  - `Proxy-Authorization: `向代理服务器发送验证信息
  - `TE` 传输编码方式
- 响应首部
  - `Accept-Ranges: `是否支持某些种类的范围
  - `Age: ` 资源在代理缓存中的时间
  - `Etag: ` 资源标识
  - `Location: `客户端重定向到某个 URL
- 实体首部
  - `Allow: ` 资源的正确请求方式
  - `Content-Encoding` 内容的编码格式
  - `Content-Language: `内容使用的语言
  - `Content-type: ` 内容的媒体类型
  - `Expires: `内容的过期时间
  - `Last-Modified: `内容的最后修改时间

4. 常见状态码
   - 2xx 代表成功
     - `200 ok 请求成功`
     - `204 no content` 请求成功, 但没有数据返回
     - `206 partial content` 范围请求
   - 3xx 重定向
     - `301 永久性重定向` 资源被分配到新的`URL`
     - `302 临时性重定向` 资源临时被分配到新的 URI
     - `303` 资源存在另一个 URL, 使用 GET 获取资源
     - `304` 服务器允许访问资源, 但因发生请求为满足条件的情况
   - 4xx 客户端错误
     - `400 bad request` 请求存在语法错误
     - `401 ` 请求需要通过 http 认证
     - `403` 请求访问资源被拒绝
     - `404` 服务器上找不到资源
   - 5xx 服务端错误
     - `500` 服务器端在执行请求时发生了错误
     - `501` 服务器不支持当前请求的某个功能
     - `503` 服务器处于停机维护, 无法处理请求

## HTTP2

在 HTTP/1 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。

在 HTTP/2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度

1. 二进制传输

HTTP/2 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP/2 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码

2. 多路复用

在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）

帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

3. Header 压缩

在 HTTP/1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。

在 HTTP /2 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。

4. 服务端 Push

在 HTTP/2 中，服务端可以在客户端某个请求后，主动推送其他资源。
